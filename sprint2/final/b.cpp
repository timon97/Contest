/*
Спринт 2 задача B. Калькулятор
https://contest.yandex.ru/contest/22781/run-report/139750153/

-- ПРИНЦИП РАБОТЫ --
Выполнил реализацию калькулятора по обратной польской нотации.
1.Для начала считываем входное выражение в std::string, затем инициализируем stringstream,
для того чтобы всё выражение было удобно разбить на токены для последующего вычисления результата.

2. Перебираем получившиеся токены и тут возможны два случая:
2.1. рассматриваемый токен - это операция +-/*,  тогда вызываем  функцию calculate(), 
в которой снимаем из стека (считаем что данные на вход идут всегда валидные и стек не пустой)
два последних числа y и x. А затем определяем арифметическую операцию, вычисляем выражение
и возвращаем результат. Для случая с операцией деления корректируем результат
(Если результат положительный и есть остаток, то уменьшаем результат), затем результат работы
функции calculate кладем на вершину стека и продолжаем парсить токены.
2.2 рассматриваемый токен не арифметическая операция - это значит, что это int и его можно просто
конвертнуть из string к инту  с помощью std::stoi() и положить на вершину стека. 

3. После того как обработка всех токенов закончилась, у нас в стеке осталось 1 элемент -
это и есть наш итоговый результат, выводим в stdout.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Исходя из описания выше данный алгоритм будет работать корректно при условии, что данные на
вход будут поступать валидные, что и соответствует задаче.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
1. Чтение ввода - это O(N) N - длина строки
2. Инициализация stringstream - это O(N) - длина строки.
3. Перебор и обработка токенов
3.1. push() и pop() в стек O(1)
3.2. вычисление calculate() тоже O(1)
3.3. stoi() - O(N) N - длина строки.
Итого перебор всех токенов и их обработка результатов в худшем случае займёт O(N).

Итоговая сложность всей программы будет O(N) + O(N) + O(N) = O(N) - то есть зависеть от
длины переданной на вход строки.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
1. string input - займёт O(N) памяти.
2. stringstream - так же займёт O(N) памяти.
3. stack - так же займет O(N) памяти

Итого результирующая сложность по памяти O(N).
*/
#include <iostream>
#include <sstream>
#include <string>
#include <stack>

int calculate(std::stack<int>& stack, const char oper) {
    int y = stack.top();
    stack.pop();
    int x = stack.top();
    stack.pop();

    if (oper == '+') {
        return x + y;
    } else if (oper == '-') {
        return x - y;
    } else if (oper == '*') {
        return x * y;
    } else {
        int result = x / y;
        if ((x < 0) != (y < 0) && x % y != 0) {
            result--;
        }
        return result;
    }
}

int main() {

    std::string input;
    std::getline(std::cin, input);
    std::istringstream iss(input);

    std::stack<int> stack;

    std::string token;
    while (iss >> token) {
        if (token == "+" || token == "-" || token == "*" || token == "/") {
            stack.push(calculate(stack, token[0]));
        } else {
            stack.push(std::stoi(token));
        }
    }

    std::cout << stack.top();
    stack.pop();
    return 0;
}
